<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Yuguo's Blog</title>
		<link>http://yuguo.us</link>
		<atom:link href="http://yuguo.usfeed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>爱上北上广深</title>
				<description>&lt;p&gt;在QQ空间看到这样一段话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;快毕业时，老师告诉我们，如果可以的话，毕业后还是留在家乡工作创业，非走不可也不要太远。不然，就算没日没夜终于拼到拿二三十万年薪，你会发现，留在家乡的同窗也已有房有车有体面工作，享受家乡低消费的乐趣，成天去婆婆或是丈母娘家蹭饭，没事跟亲妈撒娇，隔三差五跟各个时期的朋友同事喝个酒，真遇到个麻烦事整个家族拥上来一块解决，每天早晨一脚油门就蹬到单位，节假日去你喜欢的所谓大城市旅个游，旅行结束后躺在床上说句还是家里舒服。而与此同时，你正拿着二三十万的年薪给老板干着五十万的工作，你享受着高消费，你租房，你单身，你有事只能自己冲上去解决，你一年回家两到四次，每次为了待这几天要跟上万人抢票，然后匆匆忙忙大包小包地赶。你每次离开的时候，都会觉得父母又苍老了，算下来一年两到四次见面的话，应该还剩不足百次了。你想起了小时候，你想回家了，可，一切好像都有点晚了，回到家乡意味着放弃了那么多年的努力，意味一切又要回到了刚毕业那年，从零开始，所以你不敢，于是又预定了离开的票……
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在刚开始工作的时候，我也确实有过这样的困惑，钱确实比小城市赚的多一点，但是赚多少都不够花，工作一年几乎攒不到钱，那时候的心情是非常纠结的。&lt;/p&gt;

&lt;p&gt;我后来的女朋友也告诉我，她有过类似的孤独迷茫感受，要不是遇见我，她可能都没法在深圳继续过下去，准备回成都了。&lt;/p&gt;

&lt;p&gt;但是现在，她很庆幸当初留下了，也开始觉得深圳是比成都更好的城市。我的想法已经渐渐清晰起来。&lt;/p&gt;

&lt;p&gt;年轻人应该多挣钱，与此同时，除了稍微留一点去投资理财，其余的全花掉。&lt;/p&gt;

&lt;h2&gt;首先，为什么要多挣钱？&lt;/h2&gt;

&lt;p&gt;钱只是数字，它代表你提供的服务有多大的价值。在小城市赚的少，大城市赚得多，为什么？因为大城市的人提供的价值普遍大一些，他们在给社会做贡献。在小城市“有车有房有体面的工作”在我看来是在混日子，我这样说会显得有点刻薄，但大部分人就是如此。&lt;/p&gt;

&lt;p&gt;“遇到麻烦事整个家族一起解决”，因为小城市里生活，关系网重于能力，没有关系网几乎什么事情都办不下来。但是在深圳这样的城市，即使一个人，很多事情都好解决，政府也（相对）有效率。&lt;/p&gt;

&lt;p&gt;“有事情只能自己解决”这是专业主义的态度。整个社会每个人都专业地做好自己的事情，而不依赖跟其他人的关系，这才是正常的社会吧。&lt;/p&gt;

&lt;h2&gt;为什么要多花钱？&lt;/h2&gt;

&lt;p&gt;过于节省的生活其实是对社会经济不利的，是经济凋敝的表现。大家都活跃地交换自己提供的服务，并享受其他人的服务，社会才会涌现更多高效的服务。&lt;/p&gt;

&lt;p&gt;所以我买扫地机器人，买两台MacBook，买机械键盘，电动牙刷……总之在一些个人消费上，不吝啬。&lt;/p&gt;

&lt;p&gt;最后，花的钱多了，也会更加努力地思考，如何让自己提供最大的价值，以获得对应的金钱认可。&lt;/p&gt;

&lt;p&gt;这一年来在深圳买车买房，越来越喜欢这个城市，我会在父母年老之前想办法再买一套房，接他们来深圳。&lt;/p&gt;

&lt;p&gt;最后，为什么往往能看到“逃离北上广深”的文章，看不到“爱上北上广深”的文章？因为离开的人（或者根本就没能力来的人）需要一些“理由”说服自己是明智的，而在北上广深认真生活的人，根本无需理由。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/2014/03/money-flow.jpg&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 01 Mar 2014 10:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/money-flow/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/money-flow/</guid>
			</item>
		
			<item>
				<title>卓有成效的管理者</title>
				<description>&lt;p&gt;最近在和菜头的公共账号里看到一篇文章《Netflix文化：自由与责任》，该文翻译自Netflix的PPT，阐述了明星IT公司Netflix的企业文化：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;用市场最高价格雇佣高效能人士组成团队。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;我的观点是，对于脑力劳动者的自我修养，这些看法值得我们学习，但是&lt;strong&gt;对于管理者，这一文化纯属心灵鸡精，并没有可操作性，高效能的管理者并不奢求完美的人才，他能让平凡的人成就不平凡的事业。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在德鲁克的经典管理书《卓有成效的管理者》里面，他建议管理者学会这么一种创建组织的方式：若某人在某一方面具有特长，就要让他充分发挥这一特长。而不应该期望另寻万能的天才来达成绩效。这本书堪称提高脑力劳动者专业度的圣经。&lt;/p&gt;

&lt;p&gt;值得在最开始就明确的是，本书的“管理者”的定义并不是以他有没有下属而定，而是看他是否能做决策，并承担起做贡献的责任。本书的英文名《The Effiective Executive》中Executive既有传统的“管理人员”的意思，又有只负责执行而不负责判断的“执行者”的意思。所以在本书和本文的语境下，请牢记这一点：管理者泛指工作者、经理人员和专业人员，由于其职位和知识，他们必须在工作中做出影响整体绩效和成果的决策。&lt;strong&gt;所以程序员也属于管理者。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其次我们要明确的是什么是“有效”，为什么“有效”很重要。在旧的社会中，在脑力劳动者没有占据社会这么大比例的时候，管理者的“有效”并不是一个很难评估的指标。因为在体力劳动的社会，无论是执行者还是小的领导（可以认为是监工），他们要做的事情是固定的、可衡量的，而最优秀的人和平均的人的产出差别也不会超过两倍，所以雇员是否有效是一目了然的事情。但是在现在，管理者是否“有效”是一个很难回答的问题。程序员的产出是代码，但实际上是他思维的表现，他坐在桌子前思考，没有人知道他在思考工作还是思考今天的晚餐。而高效能的管理者的成果能比一般管理者高出十倍以上！所以现在一个管理者是否有效是一个非常重要的问题。&lt;/p&gt;

&lt;p&gt;有天生的管理者吗？我在上学的时候觉得自己这辈子应该做不了管理类的工作，因为我不是对人会很热情很自来熟的类型。我没有办法很快记住一个人的名字，也有点脸盲，在团队中也不是会说很多话的人。我喜欢专注做事情，我以为我会一辈子搞技术。&lt;/p&gt;

&lt;p&gt;但是管理者的有效性不是天生的。假如卓有成效是一种天赋，那就糟糕了，今天的大型组织的文明，所依赖的是大批具有一定有效性而且可以担任管理者的人。事实上，卓有成效的管理者并无性格上的共性，唯一的共性就是他们要经过长期的训练，从而养成五个思维上的习惯。&lt;/p&gt;

&lt;p&gt;这五个思维习惯是本书的核心，环环相扣，非常经典。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有效的管理者知道他们的时间用在什么地方。&lt;/li&gt;
&lt;li&gt;有效的管理者重视对外界的贡献。&lt;/li&gt;
&lt;li&gt;有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。&lt;/li&gt;
&lt;li&gt;有效的管理者集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。&lt;/li&gt;
&lt;li&gt;最后，有效的管理者必须善于做有效的决策。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;每一条都会花一章的时间来展开说明，每一章都有些让我醍醐灌顶的部分。比如“有效的管理者重视对外的贡献”：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;重视贡献，才能使管理者的注意力不为其本身的专长所限，不为其本身的技术所限，不为其本身所属的部门所限，才能看到整体的绩效，同时也才能使他更重视外部世界。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;你们感受一下。&lt;/p&gt;
</description>
				<pubDate>Sat, 22 Feb 2014 10:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/the-effective-executive/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/the-effective-executive/</guid>
			</item>
		
			<item>
				<title>有兴趣就够了吗？</title>
				<description>&lt;p&gt;2012年我组织ISUX设计团队十来个人一起翻译了一本&lt;a href=&quot;http://yuguo.us/weblog/isux-and-smashing-book/&quot;&gt;《Smashing Book
3》&lt;/a&gt;，后来我在腾讯大厦食堂上面一块简陋的幕布上分享图书出版背后的一些幕后故事的时候，两个毕业生小伙子联系到我，说他们很有兴趣翻译英文书，如果有机会就给他们关照一下。&lt;/p&gt;

&lt;p&gt;我刚经历翻译一本书搞的每天睡眠不足的阶段，所以非常清楚翻译是很耗费时间和脑力的工作，阮一峰曾经翻译完《More Joel on Software》之后说到：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  话说今年8月份，我翻译完More Joel on
  Software，已经精疲力竭，对这种通过长时间击键，将英语改写为汉语的廉价体力+脑力劳动深恶痛绝，再也不想干了。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;对，当时的我就是抱着再也不想干了的想法跟他们说，如果出版社有更多的需求，而你们有时间和兴趣的话，我就把任务转给你们。&lt;strong&gt;但我是没有时间涉及到里面去了&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;后来出版社跟我说，有一本响应式设计流程的书。我觉得这个题材还不错，就转给这两个年轻人去翻译。他们评估之后觉得两个月应该能完成，我答应到时候帮他们校对一下。&lt;/p&gt;

&lt;p&gt;但是结果他们出于各种各样的理由（搬家啦，参加其他活动啦，加班啦）延期交稿。延期了也不主动告知我原因，所有的沟通都是我主动去问，然后才告诉我延期了，保证下个星期交道，催了好几次确一拖再拖，耗费4个月的时间也没能完成各自预期的50%的工作量。我只好拉了其他人来帮忙剩下的部分。&lt;/p&gt;

&lt;p&gt;而他们完成的那60%也只能算勉强及格，错译、漏译的情况常常出现，可能是能力问题吧，但给我的感觉却是根本就不上心的缘故。&lt;/p&gt;

&lt;p&gt;直到现在，我还在收拾这个烂摊子，虽然这个项目本不该由我来主导，但既然我知道最终印出的书上会写上我的名字，我就有责任投入时间去做好它。&lt;/p&gt;

&lt;p&gt;最后，我给所有&lt;strong&gt;刚开始工作的年轻人&lt;/strong&gt;的建议：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;老板给你任务，根本不关心你有什么理由，只关心你完成没有。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;扯一些理由（特别是私人的理由）根本就是不专业的态度。不要说自己没能完成的事情是由于什么原因导致的，而要以诚恳的态度说明当前进度，以及未来是否能如期完成目标，如果不能，就直接说出来。这样老板可以对进度有所了解和预期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在职场中，我们评估一个人并不是根据他的能力，而是他的责任。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果一个项目成功或者失败，准时完成或者延误，都有一个人能主动汇报和负责，拍着胸脯说“我负责”。那他就应该是项目主导和骨干，而不论年龄和资历。&lt;/p&gt;

&lt;p&gt;而我们最终评估一个人是否应该升职加薪，不是看他的能力，也不是看他投入的时间，更不是看兴趣，只是看他的责任。他在一个个项目中都承担起了责任，就是一个有责任心的人，就能更加委以重任。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在能力不足的时候，唯有投入大量的时间。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;新人没经验，知识不丰富可以理解，但是以此为理由输出不合格的产品，那就是自己的问题。我在实习的时候，通宵睡在公司都经历过。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;你有没有想着把你的产品和你的名字联系起来？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有些成功的作品，项目，我们都希望把自己的名字同它联系起来，让人们谈到这个项目的时候，也能为自己增光添彩。但是在这个项目还在孵化中的时候，你是否有把自己的名字跟项目联系起来的觉悟？&lt;/p&gt;

&lt;p&gt;保证质量并不是其它人的责任，不是你的reviewer的责任，不是测试的责任，就是你的责任。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;你是否珍惜你的时间？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实中国的教育很缺乏对时间管理的教育，十几年的学生生涯中，该干什么是很固定的，任务持续的时间也是老师安排的。而在踏入工作之后，任务一下子变得不是很明确，时间也没有那么固定。&lt;/p&gt;

&lt;p&gt;我有接近4年的工作经验（包括实习），在这过程中从纯粹的干活，到现在慢慢投入越来越多的时间在团队管理上，我有一些经验之谈。&lt;/p&gt;

&lt;p&gt;有些人觉得刚毕业确实是比较忙的，因为活儿都丢给毕业生去干，等渐渐当上管理层，就闲散了，因为可以把活儿丢给别人干了嘛！事实是截然相反的，管理者要做的事情比执行者更多，但是因为管理者能管理好自己的时间，做事讲究优先级，懂得授权和请求他人帮助，所以能避免“瞎忙”。&lt;/p&gt;

&lt;p&gt;所以在工作中，珍惜自己的时间尤为重要。这里推荐《卓有成效的管理者》给所有从事脑力劳动的年轻人，书中会写到管理者第一个需要练习的就是管理时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自己的责任&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在这个项目中，我也有自己的责任。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有在最开始做出合理的时间评估&lt;/li&gt;
&lt;li&gt;没有根据人员的强项来安排任务&lt;/li&gt;
&lt;li&gt;没有充分沟通&lt;/li&gt;
&lt;li&gt;自己虽然有责任感，但只是“消极”的责任感，不要把事情弄砸，而不是“积极”想做这个项目的主动精神&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在组织中工作，并不是特别需要很强的个人能力或者天赋，但是要稳扎稳打，虚心学习，不要玻璃心，真诚沟通，珍惜每一次输出的机会。&lt;/p&gt;

&lt;p&gt;共勉。&lt;/p&gt;
</description>
				<pubDate>Thu, 13 Feb 2014 20:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/interest-is-not-good-enough/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/interest-is-not-good-enough/</guid>
			</item>
		
			<item>
				<title>《编剧的艺术》</title>
				<description>&lt;p&gt;最近读了一本编剧入门的经典教材《编剧的艺术》，这本书非常好，让我对创作有了新的认识。&lt;/p&gt;

&lt;p&gt;任何书，任何戏剧，任何ppt，任何文章……人类创造的任何优秀的作品，都有一个共同点：“一个明确的前提”。&lt;/p&gt;

&lt;p&gt;小时候我们语文课作业经常是“概括本文中心思想”，这给我们一个错觉：中心思想是事后提炼出来的。&lt;/p&gt;

&lt;p&gt;其实不然，中心思想也就是《编剧的艺术》一书中所定义的“前提”，是在创立之初就必须明确的。&lt;/p&gt;

&lt;p&gt;创作者必须确定一个清晰明确的前提，可以是一句简单的话。比如《罗密欧与茱丽叶》的前提是“伟大的爱情战胜一切”。然后在整个作品的创建中时刻坚守这一前提，任何人物和情节都必须服务这一前提，如果想到一个特别有趣的情节，但是跟前提没有关系，就必须放弃掉。&lt;/p&gt;

&lt;p&gt;整个作品中的一切都要服务于前提。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;法国著名雕塑家罗丹，精心雕塑了一座文学家巴尔扎克的像：巴尔扎克目光炯炯，身披宽袖长袍，一双手非常自然地叠合在胸前。罗丹唤来了自己的三个学生来欣赏他的得意之作。不料，三个学生不约而同地被雕像上这双栩栩如生的手吸引住了，连声赞叹：“好极了，这真是一双奇妙的手啊！”罗丹从学生的表情中感到这双手虽然塑得绝妙，可是作为整体的一部分，太突出了，起了喧宾夺主的作用，因此，他找来了一把大斧，劈里啪地把这双手砍掉了。几个学生被罗丹的举动吓得目瞪口呆。&lt;/p&gt;

&lt;p&gt;因为这个作品主要是表现和展示巴尔扎克的为人气质和精神特征，而不是表现这只手的，这只手虽然精美，但却冲淡了作品的主题，显然是多余的，应毫不犹豫地砍掉。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;《编剧的艺术》这本书被称为戏剧编剧的经典教材，但我推荐给所有人阅读。从这本书里我学到很多创作的技巧，也能在看电影的时候分辨出那些空有漂亮的主演和华丽的情节，而根本没有明确的前提的烂片。&lt;/p&gt;

&lt;p&gt;最后，所有好的书都可以用一句话来总结，但并不意味着只读这一句话就能有所收获，必须亲身去提炼，把书读厚，再把书读薄。&lt;/p&gt;

&lt;p&gt;《编剧的艺术》这本书的前提是“可以通过明确的前提、丰满的人物和升级的冲突来创造出引人入胜的剧本”。&lt;/p&gt;

&lt;p&gt;这一前提并不仅能用在戏剧创作，在创造ppt的时候也可以使用这一前提，首先确定整个ppt的前提，然后每一页都服务于这一前提。&lt;/p&gt;

&lt;p&gt;最后做一下广告，我在豆瓣新开了一个专栏&lt;a href=&quot;http://read.douban.com/column/226077/&quot;&gt;《谈谈全栈工程师》&lt;/a&gt;，会每周发表一些关于“全栈工程师（full-stack developer）”的话题，欢迎订阅。但是现在还没有正式发布的功能，我写的文章只能囤积在后台，订阅之后如果哪天能正式更新了就会在你的豆瓣帐号收到推送。&lt;/p&gt;
</description>
				<pubDate>Mon, 27 Jan 2014 16:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/art-of-dramatic-writing/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/art-of-dramatic-writing/</guid>
			</item>
		
			<item>
				<title>2013年终总结</title>
				<description>&lt;p&gt;2013年就要过去了，像往年一样总结一下过去的一年我的变化。&lt;/p&gt;

&lt;h1&gt;生活&lt;/h1&gt;

&lt;p&gt;在深圳买房了。其实这个决定做的挺突然（因为前房东不续租了），但是快速买了房并入住之后一直都是很庆幸当时下决心很快。因为6月份以后直到现在深圳的房价仍然在一路上涨，前海片区涨了20%以上，如果当时没买现在肯定更加买不到了。而且十月份后全国性的贷款收紧，这时候已经很难贷到房贷，或者很难以折扣贷到款。第三是因为这半年忙活一些软装修，包括去乐安居挑吊顶和窗帘，去宜家买摇椅，配置地毯，自己拿电钻装饰厨房，这里面有很多乐趣。最后感谢腾讯，提供部分无息贷款，福利很好，想跳槽的前端欢迎联系我：）&lt;/p&gt;

&lt;p&gt;我在今年底买了人生第一辆车，去年报的驾校也在今年年底顺利毕业，拿到了驾照。买车这个决定也做的很快，但是买了还是觉得挺值，因为有了一种“蒙多想去哪儿就去哪儿”的感觉，有关闭车窗那种与世隔绝的安静，有下雨天打在天窗玻璃上的积水，还有冬天从空调口输出的暖气，还可以在等人的时候打开天窗看书。总结来说就是安全和自由的心理感受。&lt;/p&gt;

&lt;p&gt;还买了一些对生活品质有所提高的东西。在新家厨房配置了直饮净水系统，净水的程度比桶装纯净水还要干净。买了roomba扫地机器人，节省了很多扫地的时间，而且把一些毛发，和地毯绒毛也全部吸进去，效果很好。retina MBP，超快的ssd和retina屏幕，这个体验过就回不去了。买了kpw2，比前两个kindle都好，更轻量便携，更高的dpi，还有背光灯，一样的续航能力，日本价格700+，非常超值。对我来说，物件的价值并不是一个简单的price tag，而是买回来之后自己会用多少次，每次使用给自己带来的效用值多少钱。所以一个iPhone比起android并不会贵，因为能用更久，而且可以以相对不错的价格回收。&lt;/p&gt;

&lt;p&gt;今年夏天休假去马来西亚的沙巴海滩潜水，只是最初级的浮潜，但已经能看到很美的水下景色，下定决心以后要去仙本那潜水胜地玩一玩~&lt;/p&gt;

&lt;h1&gt;工作&lt;/h1&gt;

&lt;p&gt;年初在App Store上线了一个自己的iOS App，自己不是很满意，但也确实学习到一些经验。后续忙别的工作，就没有继续做更多App了。&lt;/p&gt;

&lt;p&gt;在公司，我今年成功晋级T3高级设计师，算是一个期待了挺久，最终也顺利达成的目标。从进入腾讯到现在一共三年，每半年一次升级，都没有拉下，比较顺利，这过程中也要感谢周围的同事和领导。&lt;/p&gt;

&lt;p&gt;今年我做了大小几十次演讲，两次公司级的演讲，两次部门级的和两次跨部门的分享。其实演讲也是一种需要大量练习才能习得的技能，我现在也只是做到了最基础：弄清楚目标听众是什么，吸引他们的注意，表达我的想法。最近看了很多罗胖的罗辑思维，整体的表达非常好，我自愧太不如，以后要在这一块多加练习。&lt;/p&gt;

&lt;p&gt;今年我组织翻译和校对的书《众妙之门3》顺利出版，其实是去年一直在做的努力，在今年4月份终于有了圆满的结果。这个要感谢人民邮电出版社的编辑赵轩，感谢ISUX的小伙伴们~&lt;/p&gt;

&lt;p&gt;技术学习方面，粗而广地学了一些东西，nodejs、mongodb、objective-c、Angularjs、响应式流程等。我学技术的原则是熟练度可以不高，但原理和模式一定要理解。&lt;/p&gt;

&lt;p&gt;读书方面，今年读了很多老书，开始书架重读计划，我觉得读书不能贪多和贪数字。&lt;/p&gt;

&lt;p&gt;最后的最后，跟melody恋爱三年了，以前坐在我的自行车横杆，现在坐在我的副驾，我想，以后无论发生什么，我们也能一路走下去吧。&lt;/p&gt;
</description>
				<pubDate>Mon, 23 Dec 2013 09:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/2013-year/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/2013-year/</guid>
			</item>
		
			<item>
				<title>激励与响应</title>
				<description>&lt;p&gt;2013年12月15日，天津市政府召开新闻发布会，宣布实行小客车总量调控管理以及实施机动车限行交通管理措施，也就是“限购＋限行”。&lt;a href=&quot;http://news.xinhuanet.com/fortune/2013-12/16/c_125863248.htm&quot;&gt;原文&lt;/a&gt; 。管理措施12月16日凌晨生效。&lt;/p&gt;

&lt;p&gt;当晚天津市民排队抢购小汽车，4S店和二手车交易市场通宵营业，新车和二手车都需要加价购买。&lt;/p&gt;

&lt;p&gt;因为鼠患严重，河内的法国殖民政府曾经颁布过一条法令：人们每交出一只死老鼠，政府就给他发钱。这导致一些民众饲养老鼠，以此赚钱。&lt;/p&gt;

&lt;p&gt;因为法国皇帝希望用一种简单方便的办法征收房产税，提出了“窗户税”：即根据每一户的窗户数量来征收税收，这导致（经过近百年的变迁）法国一些房子不再建造窗户，终年潮湿阴暗。&lt;/p&gt;

&lt;p&gt;公司对部门的考核是“收入”，那么部门的BD对完谈合作的时候就会说我用平台和渠道免费营销你的产品，但是只有当你的销量达到500万的时候才免费。所以先收100万的现金，到时候再返还给商户。&lt;/p&gt;

&lt;p&gt;这样做，BD也也等于让步得到了谈判的资本，自己的KPI也达到了，但实际上股东利益并没有得到保证。&lt;/p&gt;

&lt;p&gt;简单的说，第一，一旦有激励加入游戏或者改变了激励，人们就会迅速而激烈地改变自己的行为；第二，人们是对激励做出反应，而不是对激励背后的目的做出反应。&lt;/p&gt;

&lt;p&gt;如果你对某个人或某个组织的行为感到吃惊，那后面90%隐藏着什么激励机制。&lt;/p&gt;
</description>
				<pubDate>Mon, 16 Dec 2013 09:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/motivate-and-response/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/motivate-and-response/</guid>
			</item>
		
			<item>
				<title>Bigpipe用Nodejs的实现</title>
				<description>&lt;p&gt;&lt;section&gt;&lt;/p&gt;

&lt;h1&gt;Bigpipe用Nodejs的实现&lt;/h1&gt;


&lt;p&gt;&lt;a href=&quot;http://yuguo.us/weblog/bigpipe-in-nodejs&quot;&gt;http://yuguo.us/weblog/bigpipe-in-nodejs/&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;
&lt;small&gt;Created by &lt;a href=&quot;http://yuguo.us&quot;&gt;Yuguo&lt;/a&gt;&lt;/small&gt;
&lt;/p&gt;


&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Source &amp;amp; Thanks&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/undoZen&quot;&gt;https://github.com/undoZen&lt;/a&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;什么是Bigpipe&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;是一种不局限于语言的前后端整合技术方案&lt;/li&gt;
&lt;li&gt;由Facebook首创&lt;/li&gt;
&lt;li&gt;适合比较大型的，需要大量服务器运算的站点&lt;/li&gt;
&lt;li&gt;有效减少HTTP请求&lt;/li&gt;
&lt;li&gt;兼容多浏览器
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe解决的问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;下载阻塞&lt;/li&gt;
&lt;li&gt;服务器与浏览器算力浪费
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;现有的阻塞模型&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/files/2013/12/traditional-network.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;页面解析步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;浏览器发送HTTP请求&lt;/li&gt;
&lt;li&gt;服务器接收到HTTP请求，解析请求，从存储层拉取数据，拼接HTML，发回一个HTTP响应&lt;/li&gt;
&lt;li&gt;这个请求通过网络传输到浏览器&lt;/li&gt;
&lt;li&gt;浏览器解析接收到的数据，构造DOM树，下载CSS和JavaScript&lt;/li&gt;
&lt;li&gt;浏览器下载了CSS之后，开始解析CSS，渲染页面&lt;/li&gt;
&lt;li&gt;下载JavaScript之后，开始解析JavaScript，执行JavaScript
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;传统流程&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;整个完整的页面&lt;/strong&gt;渲染依次经过以下步骤。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe解析步骤&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;每一个Pagelet&lt;/strong&gt;都经过以下每一个步骤才会出现在浏览器中，但是多个Pagelet可以同步进行处理。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe的速度提升&lt;/h2&gt;

&lt;p&gt;Facebook的Pagelet&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/2013/12/facebook.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe的速度提升&lt;/h2&gt;

&lt;p&gt;Facebook的Pagelet&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/2013/12/facebook-page-parts.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe的速度提升&lt;/h2&gt;

&lt;p&gt;页面分片越多，性能提升越明显&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/2013/12/facebook-bigpipe.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe不适合&lt;/h2&gt;

&lt;p&gt;简单页面，适合服务器直出全部HTML
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;YSlow优化建议&lt;/h2&gt;

&lt;p&gt;提早flush
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;flush()&lt;/h2&gt;

&lt;p&gt;PHP中的&lt;code&gt;flush()&lt;/code&gt;函数可以建立一个HTTP持久链接，达到分块传输的效果，YSlow建议在输出&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;之后马上&lt;code&gt;flush()&lt;/code&gt;，以便浏览器下载资源。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h1&gt;Nodejs实现Bigpipe的DEMO&lt;/h1&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Nodejs是什么&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个JavaScript运行环境&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;h2&gt;Nodejs不是什么&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不是一个库
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe in Nodejs&lt;/h2&gt;

&lt;p&gt;是一种技术方案（Bigpipe）在一种环境（Nodejs）中的实现。&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;p&gt;Bigpipe的服务器端可以用各种语言来实现&lt;/p&gt;

&lt;h2&gt;为什么使用Nodejs？&lt;/h2&gt;

&lt;p&gt;&lt;small&gt;注：Bigpipe技术的服务器端需要HTTP1.1支持，浏览器端需要JavaScript支持。&lt;/small&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Why Nodejs?&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;异步特性适合Web，适合用少量服务器服务海量用户&lt;/li&gt;
&lt;li&gt;同一种语言模板同时运行在服务器和浏览器中&lt;/li&gt;
&lt;li&gt;开源社区支持
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;关键技术点&lt;/h2&gt;

&lt;p&gt;HTTP 1.1引入分块传输编码&lt;/p&gt;

&lt;p&gt;&lt;small&gt;注：HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。&lt;/small&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;HTTP分块传输编码格式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Transfer-Encoding: chunked
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Nodejs自动开启 chunked encoding&lt;/h2&gt;

&lt;p&gt;除非通过sendHeader()设置Content-Length头。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Nodejs Express&lt;/h2&gt;

&lt;p&gt;使用Express简单架设一个web服务器（简化原生Nodejs http api），并使用jade来渲染页面模板（让代码简单）。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;res.render&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;res.render(&#39;view&#39;, option);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有两个参数时，&lt;code&gt;res.render()&lt;/code&gt;自动调用&lt;code&gt;res.send()&lt;/code&gt;，res.send包括&lt;code&gt;res.end()&lt;/code&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;res.render设置第三个参数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;res.render(&#39;view&#39;, option, function(err, html){
    res.write(html);
    res.end();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置了第三个参数时，不会自动&lt;code&gt;res.end()&lt;/code&gt;，Good！
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;发送多个pagelet&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;res.render(view, options, function (err, str) {
    if (err) return res.req.next(err)
    res.setHeader(&#39;content-type&#39;, &#39;text/html; charset=utf-8&#39;)
    res.write(str)
    if (!res.pipeCount) res.end()
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要发送n个pagelet，就可以在每渲染一个pagelet之后计数-1，当全部渲染完成之后才调用&lt;code&gt;res.end()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;layout.jade&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;doctype html

head
  title Hello, World!
  link(href=&quot;/static/style.css&quot;, rel=&quot;stylesheet&quot;)
  script(src=&quot;/static/jquery.js&quot;)
  script(src=&quot;/static/jade.js&quot;)

section#s1!=s1
section#s2!=s2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;第一部分数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Hello, World!&amp;lt;/title&amp;gt;
&amp;lt;link href=&quot;/static/style.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
&amp;lt;script src=&quot;/static/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;/static/jade.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;section id=&quot;s1&quot;&amp;gt;
&amp;lt;span id=&quot;pipe_08554240758530796_1386255294914&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;section id=&quot;s2&quot;&amp;gt;
&amp;lt;span id=&quot;pipe_020325828110799193_1386255294914&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/section&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;第二部分数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
$(&quot;#pipe_08554240758530796_1386255294914&quot;)
.replaceWith(&quot;&amp;lt;h1&amp;gt;Partial 1&amp;lt;/h1&amp;gt;&amp;lt;div class=\&quot;content\&quot;&amp;gt;&quot;+
+&quot;Hello, I&#39;m the first section.&amp;lt;/div&amp;gt;&quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;第三部分数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
$(&quot;#pipe_020325828110799193_1386255294914&quot;)
.replaceWith(&quot;&amp;lt;h1&amp;gt;Partial 2&amp;lt;/h1&amp;gt;&amp;lt;div class=\&quot;content\&quot;&amp;gt;&quot;
+&quot;Hello, I&#39;m the second section. Takes 5 seconds to render.&amp;lt;/div&amp;gt;&quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;第四部分数据&lt;/h2&gt;

&lt;p&gt;空数据（END）
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;更复杂的实现&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
big_pipe.onPageletArrive(
{id:&quot;pagelet_composer&quot;,
content:&quot;&amp;lt;HTML&amp;gt;&quot;,
css:&quot;[..]&quot;,
js:&quot;[..]&quot;,
…}
);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h1&gt;Thank You!&lt;/h1&gt;

&lt;p&gt;&lt;small&gt;Created by &lt;a href=&quot;http://yuguo.us&quot;&gt;Yuguo&lt;/a&gt;&lt;/small&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;课后问答&lt;/h2&gt;

&lt;p&gt;Bigpipe对SEO的影响是什么？如何解决？
&lt;/section&gt;&lt;/p&gt;
</description>
				<pubDate>Fri, 06 Dec 2013 09:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/bigpipe-in-nodejs/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/bigpipe-in-nodejs/</guid>
			</item>
		
			<item>
				<title>前端工业化3：VCS</title>
				<description>&lt;p&gt;任何慎重地对待编程的程序员和团队都会使用VCS（主要是Git或者SVN），主要有这样几个作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于程序员个人，记录代码避免丢失，方便查看修改并回溯，分支同一个代码仓库中的不同需求，记录小型里程碑&lt;/li&gt;
&lt;li&gt;对于团队协作来说，VCS的自动合并能省去我们95%的合并代码工作量&lt;/li&gt;
&lt;li&gt;对于代码审查者来说，方便监视主干代码的修改，并接受或者拒绝提交的代码&lt;/li&gt;
&lt;li&gt;通过使用一些行为钩子，可以在VCS行为之前或者之后自动触发其它事件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我在加入ISUX团队之前是一个菜鸟学生，从来没有使用过VCS，对于当时的我来说，SVN就只有一个作用：&lt;strong&gt;合并代码到主干&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;所以当时的我既累又容易出错，因为我使用SVN的方法完全错误：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在trunk上直接开发&lt;/li&gt;
&lt;li&gt;完成一个完整的需求才commit一次&lt;/li&gt;
&lt;li&gt;只commit这个需求需要的文件和代码，人工检查&lt;/li&gt;
&lt;li&gt;代码库中残留越来越多没有提交的脏代码&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我没有利用到SVN的其它功能：频繁记录代码里程碑，多个分支切换，让这些外部信息从大脑里释放，保持代码库的干净。但是随着我需要接入的项目越来越多，越来越需要快速在多个项目切换，并且也开始使用其它VCS（Git），我开始对VCS有了更好的理解。&lt;strong&gt;VCS并不只是帮助代码合并的团队工具，也是个人管理代码的很好方式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我现在非常喜欢使用Git管理版本，因为它跟SVN有一个完全不同的地方是它是分布式的，完整的代码库存在在每一台部署了代码库的机器上，我在本地切换分支，新建分支非常快，秒级生效，而且无需网络就可以commit代码。最后，世界上最好的开源代码社区是使用Git搭建（Github），你还有什么理由不使用Git呢？&lt;/p&gt;

&lt;p&gt;关于各种VCS的用法和实践，其实我不用在本文一一说明，因为资料已经太多。推荐阅读：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;&amp;lt;http://www.ruanyifeng.com/blog/2012/07/git.html&gt;&quot;&gt;Git分支管理策略&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&amp;lt;http://www.tigris.org/scdocs/SVNTips.html.zh-cn&gt;&quot;&gt;SVN最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&amp;lt;http://ihower.tw/blog/archives/5140&gt;&quot;&gt;Git flow开发流程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Tue, 26 Nov 2013 01:00:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/front-end-industrialize-vcs/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/front-end-industrialize-vcs/</guid>
			</item>
		
			<item>
				<title>前端工业化2：缓存</title>
				<description>&lt;blockquote&gt;&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and naming things.&lt;/p&gt;

&lt;p&gt;-- Phil Karlton&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;缓存基础&lt;/h2&gt;

&lt;p&gt;在开始讲缓存技术之前，需要先了解设置缓存有两个作用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对客户来说，减少请求，可以更快加载页面。如果客户是在手机上用3G访问页面，那也能节省他的流量。&lt;/li&gt;
&lt;li&gt;对网站来说，减少带宽压力，如果有1亿的访问量，如果能在CSS上节省10k，那也是非常庞大的流量节省。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;从技术上讲，有两种技术被统称为“缓存”。&lt;/p&gt;

&lt;p&gt;一个被称为&lt;strong&gt;高速缓存&lt;/strong&gt;，浏览器直接从缓存中读取文件而不发出任何请求。另一个是&lt;code&gt;HTTP 304&lt;/code&gt;（Cache Control），浏览器会询问服务器文件是否更改，服务器回答没有修改（304），或者修改了（200）。&lt;/p&gt;

&lt;p&gt;想要详细的了解，可以看看我去年的一篇旧文&lt;a href=&quot;http://yuguo.us/weblog/send-the-correct-headers-to-leverage-browser-caching/&quot;&gt;如何正确设置缓存&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;结论是：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;200(缓存)是最快的，因为没有请求发生。304则产生了HTTP请求：浏览器发送一个带有&lt;code&gt;If-Modified-Since&lt;/code&gt;的请求，服务器根据情况返回304来告诉浏览器使用本地文件。&lt;/p&gt;

&lt;p&gt;所以304比200（缓存）慢一点，静态文件都应该使用Expires头来减少请求，提高访问速度。（根据HTTPWATCH的说法：“Don&#39;t cache HTML, Cache everything else forever”）&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;Ajax与缓存&lt;/h3&gt;

&lt;p&gt;Ajax调用就像任何其他的HTTP请求一样可以用来构建一个网页。然而，由于其动态的性质人们常常忽略了可以缓存它们而从中受益。&lt;/p&gt;

&lt;p&gt;高性能网站建设的第14条规则:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;缓存Ajax&lt;/p&gt;

&lt;p&gt;确保您的Ajax请求遵循这条规则，特别是包含一个Expires头。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;现代浏览器的HTTP系统和缓存系统要比Ajax的&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象更靠近底层. 在这个层面上，浏览器并不知道或关心Ajax请求。它只是服从正常的基于从服务器返回的HTTP响应头缓存规则。&lt;/p&gt;

&lt;p&gt;如果你已经知道HTTP缓存，您可以将这种知识应用到Ajax的缓存。&lt;/p&gt;

&lt;p&gt;当然，如果您使用Ajax的POST方法，这并不适用，因为POST请求不会被缓存。如果您的Ajax请求有安全性要求，你应该总是使用POST方法，例如：银行帐户的资金转账。&lt;/p&gt;

&lt;h2&gt;缓存与更新缓存&lt;/h2&gt;

&lt;p&gt;在几年前，我们团队控制缓存的唯一办法就是把资源丢到&lt;code&gt;/ac/&lt;/code&gt;路径上去发布，CDN对这个文件夹的处理方式是输出的HTTP header设置更长的缓存时间。而要更新缓存就是手动修改对文件引用路径的query string。&lt;/p&gt;

&lt;p&gt;历史在进步，后来我们的CDN权限支持url query string的方法来吐出对应的缓存header。从这个时候开始，我们的资源请求都变成了这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://ctc.qzonestyle.gtimg.cn/qzone_v6/icenter.css?max_age=19830212&amp;amp;d=131016151112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过修改query string，就可以控制返回header的cache-control。后面的d则是无意义的字符串，当有新版本的时候我们需要半自动去修改它，对于浏览器来说只要修改了query string，它就认为是请求了新文件，从而放弃本地缓存而重新请求。&lt;/p&gt;

&lt;p&gt;这种通过修改query string更新缓存的方法有几个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这种方法是替换的方法来发布，那么在“html生效”和“css生效”之间如果出现任何时间差，哪怕是10s，就会出现错误的情况。尤其是雪碧图如果是自动计算生成的，错位就很严重了，几乎满屏的雪碧图都会错位。腾讯有几十台CDN，无法保证生效时间的精确性。&lt;/li&gt;
&lt;li&gt;可能遭到缓存攻击，具体可以看看&lt;a href=&quot;http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1&quot;&gt;前端工程与性能优化（上）：静态资源版本更新与缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可能被网络提供商保存一份旧文件的副本，这样即使我们更新了&amp;amp;d=xxxx这个时间戳，网络提供商也仍然给你老的文件。也就是说浏览器认为这是新文件，向网络重新请求，而网络提供商可能认为这还是老文件，所以给你旧文件。&lt;/li&gt;
&lt;li&gt;发布流程麻烦，前端工程师需要同时关注样式的生效，和时间戳的生效。&lt;/li&gt;
&lt;li&gt;缺乏对组件的动态管理和统计，因为我们相当于在本地生成了一个完整的public静态资源文件夹，然后发布出去，从那以后就跟前端没有关系了。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;修改文件名&lt;/h3&gt;

&lt;p&gt;现在我们前端同学经过跟运维同事的讨论，总结出一套更好的更新缓存的办法，修改资源的名称。所以如果现在如果你可以访问QQ空间公测版（V8）的话，抓包会发现这样的CSS请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://ctc.qzonestyle.gtimg.cn/aoi/icenter-wei131025143515.css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新的文件名有很多好处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这种方法采用增量的方法来发布，不存在“html生效”和“css生效”之间的延迟，因为css可以提前发布生效，html再调用新的文件&lt;/li&gt;
&lt;li&gt;遇到问题回滚简单，不用回滚所有的静态资源，只需要回滚html&lt;/li&gt;
&lt;li&gt;完全杜绝了网络提供商提供旧文件副本的问题&lt;/li&gt;
&lt;li&gt;使用不规律的文件名，不可能遭到缓存攻击&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;我只是简单提到了运行原则，但是实际操作中有很多细节要处理，包括前端同学要注意的和运维同学在CDN上的工作量。新的缓存策略现在还在试行之中，所以也没有全面部署，只有在未来有了更自动化的方案的时候才会全面部署。&lt;/p&gt;
</description>
				<pubDate>Wed, 30 Oct 2013 14:00:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/frontend-industrialize-2/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/frontend-industrialize-2/</guid>
			</item>
		
			<item>
				<title>前端工业化1：自动化</title>
				<description>&lt;p&gt;最近在学习百度前端工程师张云龙的F.I.S系统的时候，了解到他关于“前端工业化”的理解，我也经历过很多前端架构方法和架构工具的变迁，所以希望借写这篇文章的机会，自己也整理一下。&lt;/p&gt;

&lt;p&gt;之前有读者建议我写写关于D.R.Y的经验，其实好的架构能让你免于Repeat Yourself。但是架构的目的不仅限于在开发者侧更轻松，更有组织，而更重要的是在客户侧更简洁纯粹。&lt;/p&gt;

&lt;p&gt;张云龙关于架构有一段话很好：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;因为优化原则中很多要求是与工程管理相违背的，比如“把css放在头部”和“把js放在尾部”这两条原则，我们不能让团队的工程师在写样式和脚本引用的时候都去修改一个相同的页面文件。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;就像是硬币的两面，&lt;strong&gt;一面朝客户，关注性能、缓存、减少重复、保持一致；一面朝前端团队，关注维护、发布流程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;小型团队也需要合理的架构，这样可以增强扩展性和安全性。当网站从小团队渐渐发展到大团队，网站渐渐拥有千万用户的时候，整个流程更加要自动化。如果说求职的时候需要的“精通CSS”是考察开发者手工技艺，那么前端工业化就是关于如何让开发者团队可以无缝工作。&lt;/p&gt;

&lt;p&gt;先介绍我们Qzone团队是怎样从刀耕火种的原始时代过度到现在的。&lt;/p&gt;

&lt;h2&gt;手工&lt;/h2&gt;

&lt;p&gt;大概是2010年之前，我们SVN的目录结构很简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌ html
├ public
├ PSD
├ 规范
└ 一些批处理脚本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;public里的东西就是对应外网发布的静态资源，包括css和图片，雪碧图全手工拼接。外网代码中甚至能看到注释。&lt;/p&gt;

&lt;p&gt;CDN输出静态资源采用统一的缓存规定，好像是一个小时。要发布新代码就直接发布覆盖旧文件，反正缓存时间不长。&lt;/p&gt;

&lt;p&gt;但是我们也有长缓存的需求，比如一个黄钻vip的图标，可能一年都不会变，这时候我们规定了一个目录叫/ac/，代表长缓存，至于有多长，这个没法定制，反正运维人员给CDN统一设定了一个很长的时间，开发者想长缓存的东西就丢进去好了。&lt;/p&gt;

&lt;p&gt;这个/ac/目录出于某种神秘的原因甚至不在SVN的管理之中，我们要修改的话直接去服务器上拿（后来那台服务器挂了，我们就从外网拿）。&lt;/p&gt;

&lt;h2&gt;cssgaga&lt;/h2&gt;

&lt;p&gt;因为我们发布文件的第一步需要把文件放在一台服务器上，然后通过发布系统分发到CDN。放文件这个过程不是很优雅，也不太可靠。需要我们打开两个资源管理器（远程服务器还要输入用户名和密码），然后拷贝过去。&lt;/p&gt;

&lt;p&gt;第二步，分发系统（ARS）需要知道文件在哪台服务器上的哪个路径（linux路径），所以我们提交发布单的时候还要提供linux路径列表（称为提单列表），这就很麻烦。&lt;/p&gt;

&lt;p&gt;于是我们的团队成员&lt;a href=&quot;http://www.99css.com/&quot;&gt;yt&lt;/a&gt; 就研发了一个工具叫做&lt;a href=&quot;http://www.99css.com/archives/tag/cssgaga&quot;&gt;cssgaga&lt;/a&gt;。在windows上运行，简单配置之后，只要把需要发布的文件拖拽到工具里，就可以自动登录远程服务器并且把文件放在对应的地方，非常方便。&lt;/p&gt;

&lt;p&gt;再后来，yt慢慢在cssgaga中加入了更多的功能，比如css文件中的@import语法，可以自动合并成一个css文件，这样减少了http请求和渲染阻塞。&lt;/p&gt;

&lt;p&gt;还有data-uri，可以把引入的图片变成data-url，进一步请求，不过这个比较极端，很少用到。比如图片关联性检查，会遍历CSS中对img的引用，并自动生成提单列表。&lt;/p&gt;

&lt;p&gt;真正让cssgaga成为团队必不可少人人都用的是在2010年12月，cssgaga加入了自动雪碧图的功能，那篇介绍雪碧图功能的文章获得了80个评论。因为市面上的雪碧图工具都不太好用，拼雪碧图还处于半手工的状态，而cssgaga是完全自动化的。&lt;/p&gt;

&lt;p&gt;其实cssgaga这几年一直都在更新，加入了大量团队需要的功能，但是最核心的几条原则从来没有改变过：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;本地的CSS源码也是完全合法的语法，没有自定义的语法规则，可以直接打开静态页面，最终cssgaga生成的代码也是最符合雅虎14条的压缩代码。&lt;/li&gt;
&lt;li&gt;assets之间的关系通过合法的语法关联起来，而不是像F.I.S或者Grunt那样有一个配置关联表。举例来说，多个css组件被@import到同一个A.css中，然后拖A.css的时候就会自动搜寻相对路径中的那些css进来。拖某个css到cssgaga中（并勾选检查关联性），就会自动搜寻当前目录下所有@import了这个css的css文件，并全部发布。&lt;/li&gt;
&lt;li&gt;黑盒+不开源&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我很欣赏yt有自己的坚持，有清晰的理念支持的工具，但是我们也应该了解其他可能的选择。&lt;/p&gt;

&lt;h2&gt;Shell编程&lt;/h2&gt;

&lt;p&gt;之前写过一篇文章&lt;a href=&quot;http://yuguo.us/weblog/make-bootstrap/&quot;&gt;Bootstrap的编译机制&lt;/a&gt;，当时Bootstrap的CSS文件是使用Make来编译的，如果你没有看过这篇文章，强烈推荐你先阅读这篇文章，再回来也许能更好的理解Make。&lt;/p&gt;

&lt;p&gt;GNU make是一个方便的工具，目的是把大量的shell 命令组合起来完成一个任务。这些命令之所以能组合起来，跟Linux哲学是息息相关的：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;程序要能协作。程序要能处理文本流，因为这是最通用的接口。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;程序协作是通过“依赖”来实现，而make能很好地解决任务之间的依赖问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gh-pages: bootstrap docs
    rm -f docs/assets/bootstrap.zip
    zip -r docs/assets/bootstrap.zip bootstrap
    rm -r bootstrap
    rm -f ../bootstrap-gh-pages/assets/bootstrap.zip
    node docs/build production
    cp -r docs/* ../bootstrap-gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;gh-pages是工作目标；&lt;/li&gt;
&lt;li&gt;bootstrap docs是必要条件；&lt;/li&gt;
&lt;li&gt;以后的6行是命令&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Makefile的语法是linux shell语法，所以对于前端开发来说需要一定的学习成本。这里有一篇不错的文章，可以看一下&lt;a href=&quot;http://www.linuxforu.com/2012/06/gnu-make-in-detail-for-beginners/&quot;&gt;GNU Make in Detail for Beginners&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;Grunt&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://Gruntjs.org&quot;&gt;Grunt&lt;/a&gt;的自我介绍是：“The JavaScript Task Runner”。&lt;/p&gt;

&lt;p&gt;Grunt 是一个开源的基于任务 (Task) 的前端构建框架。它除了有 Jake 的优点（跨平台、开发简单）以外，还有一套设计良好的 task 框架用来组织各种构建任务。Grunt 内置了几个非常常见的构建任务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; concat - 组合各种文件&lt;/li&gt;
&lt;li&gt; lint - 用 JSHint 检查代码&lt;/li&gt;
&lt;li&gt; min - 用 UglifyJS 压缩代码&lt;/li&gt;
&lt;li&gt; qunit - 跑 QUnit 单元测试&lt;/li&gt;
&lt;li&gt; watch - 当源代码文件发生变化时自动执行任务&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;除此之外还可以通过 npm 来方便的获取几百个现成的 task，比如用 closure 而不是 UglifyJS 来压缩 js，或者用 less 来生成 css，又或者用 jslint 而不是 jshint 来检查语法等，这些任务都可以在 npm 上找到。如果这些任务无法满足你的需求，Grunt 还允许你方便的添加自定任务，就像写 nodejs 代码一样简单。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于前端开发者来说，Grunt语法可比Shell友好多了，而且Gruntfile.js是合法的javascript文件，在里面可以运行任何合法的javascript代码，非常灵活。&lt;/strong&gt;关于从Shell过度到Grunt这个过程，有兴趣的可以参考这篇文章&lt;a href=&quot;http://lostjs.com/2012/12/08/Grunt-the-best/&quot;&gt;Grunt -- 最好的前端构建框架&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;话分两边，工具侧我们一直没有停止进步，朝着更自动化的方向迅猛发展。那么真正面向用户的缓存和请求侧又有哪些进展呢，下一篇日志会讲讲缓存和更新缓存。&lt;/p&gt;
</description>
				<pubDate>Fri, 25 Oct 2013 14:00:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/frontend-industrialize/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/frontend-industrialize/</guid>
			</item>
		
	</channel>
</rss>