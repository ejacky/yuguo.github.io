<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Yuguo's Blog</title>
		<link>http://yuguo.us</link>
		<atom:link href="http://yuguo.us/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>《编剧的艺术》</title>
				<description>&lt;p&gt;最近读了一本编剧入门的经典教材《编剧的艺术》，这本书非常好，让我对创作有了新的认识。&lt;/p&gt;

&lt;p&gt;任何书，任何戏剧，任何ppt，任何文章……人类创造的任何优秀的作品，都有一个共同点：“一个明确的前提”。&lt;/p&gt;

&lt;p&gt;小时候我们语文课作业经常是“概括本文中心思想”，这给我们一个错觉：中心思想是事后提炼出来的。&lt;/p&gt;

&lt;p&gt;其实不然，中心思想也就是《编剧的艺术》一书中所定义的“前提”，是在创立之初就必须明确的。&lt;/p&gt;

&lt;p&gt;创作者必须确定一个清晰明确的前提，可以是一句简单的话。比如《罗密欧与茱丽叶》的前提是“伟大的爱情战胜一切”。然后在整个作品的创建中时刻坚守这一前提，任何人物和情节都必须服务这一前提，如果想到一个特别有趣的情节，但是跟前提没有关系，就必须放弃掉。&lt;/p&gt;

&lt;p&gt;整个作品中的一切都要服务于前提。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;法国著名雕塑家罗丹，精心雕塑了一座文学家巴尔扎克的像：巴尔扎克目光炯炯，身披宽袖长袍，一双手非常自然地叠合在胸前。罗丹唤来了自己的三个学生来欣赏他的得意之作。不料，三个学生不约而同地被雕像上这双栩栩如生的手吸引住了，连声赞叹：“好极了，这真是一双奇妙的手啊！”罗丹从学生的表情中感到这双手虽然塑得绝妙，可是作为整体的一部分，太突出了，起了喧宾夺主的作用，因此，他找来了一把大斧，劈里啪地把这双手砍掉了。几个学生被罗丹的举动吓得目瞪口呆。&lt;/p&gt;

&lt;p&gt;因为这个作品主要是表现和展示巴尔扎克的为人气质和精神特征，而不是表现这只手的，这只手虽然精美，但却冲淡了作品的主题，显然是多余的，应毫不犹豫地砍掉。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;《编剧的艺术》这本书被称为戏剧编剧的经典教材，但我推荐给所有人阅读。从这本书里我学到很多创作的技巧，也能在看电影的时候分辨出那些空有漂亮的主演和华丽的情节，而根本没有明确的前提的烂片。&lt;/p&gt;

&lt;p&gt;最后，所有好的书都可以用一句话来总结，但并不意味着只读这一句话就能有所收获，必须亲身去提炼，把书读厚，再把书读薄。&lt;/p&gt;

&lt;p&gt;《编剧的艺术》这本书的前提是“可以通过明确的前提、丰满的人物和升级的冲突来创造出引人入胜的剧本”。&lt;/p&gt;

&lt;p&gt;这一前提并不仅能用在戏剧创作，在创造ppt的时候也可以使用这一前提，首先确定整个ppt的前提，然后每一页都服务于这一前提。&lt;/p&gt;

&lt;p&gt;最后做一下广告，我在豆瓣新开了一个专栏&lt;a href=&quot;http://read.douban.com/column/226077/&quot;&gt;《谈谈全栈工程师》&lt;/a&gt;，会每周发表一些关于“全栈工程师（full-stack developer）”的话题，欢迎订阅。但是现在还没有正式发布的功能，我写的文章只能囤积在后台，订阅之后如果哪天能正式更新了就会在你的豆瓣帐号收到推送。&lt;/p&gt;
</description>
				<pubDate>Mon, 27 Jan 2014 16:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/art-of-dramatic-writing/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/art-of-dramatic-writing/</guid>
			</item>
		
			<item>
				<title>2013年终总结</title>
				<description>&lt;p&gt;2013年就要过去了，像往年一样总结一下过去的一年我的变化。&lt;/p&gt;

&lt;h1&gt;生活&lt;/h1&gt;

&lt;p&gt;在深圳买房了。其实这个决定做的挺突然（因为前房东不续租了），但是快速买了房并入住之后一直都是很庆幸当时下决心很快。因为6月份以后直到现在深圳的房价仍然在一路上涨，前海片区涨了20%以上，如果当时没买现在肯定更加买不到了。而且十月份后全国性的贷款收紧，这时候已经很难贷到房贷，或者很难以折扣贷到款。第三是因为这半年忙活一些软装修，包括去乐安居挑吊顶和窗帘，去宜家买摇椅，配置地毯，自己拿电钻装饰厨房，这里面有很多乐趣。最后感谢腾讯，提供部分无息贷款，福利很好，想跳槽的前端欢迎联系我：）&lt;/p&gt;

&lt;p&gt;我在今年底买了人生第一辆车，去年报的驾校也在今年年底顺利毕业，拿到了驾照。买车这个决定也做的很快，但是买了还是觉得挺值，因为有了一种“蒙多想去哪儿就去哪儿”的感觉，有关闭车窗那种与世隔绝的安静，有下雨天打在天窗玻璃上的积水，还有冬天从空调口输出的暖气，还可以在等人的时候打开天窗看书。总结来说就是安全和自由的心理感受。&lt;/p&gt;

&lt;p&gt;还买了一些对生活品质有所提高的东西。在新家厨房配置了直饮净水系统，净水的程度比桶装纯净水还要干净。买了roomba扫地机器人，节省了很多扫地的时间，而且把一些毛发，和地毯绒毛也全部吸进去，效果很好。retina MBP，超快的ssd和retina屏幕，这个体验过就回不去了。买了kpw2，比前两个kindle都好，更轻量便携，更高的dpi，还有背光灯，一样的续航能力，日本价格700+，非常超值。对我来说，物件的价值并不是一个简单的price tag，而是买回来之后自己会用多少次，每次使用给自己带来的效用值多少钱。所以一个iPhone比起android并不会贵，因为能用更久，而且可以以相对不错的价格回收。&lt;/p&gt;

&lt;p&gt;今年夏天休假去马来西亚的沙巴海滩潜水，只是最初级的浮潜，但已经能看到很美的水下景色，下定决心以后要去仙本那潜水胜地玩一玩~&lt;/p&gt;

&lt;h1&gt;工作&lt;/h1&gt;

&lt;p&gt;年初在App Store上线了一个自己的iOS App，自己不是很满意，但也确实学习到一些经验。后续忙别的工作，就没有继续做更多App了。&lt;/p&gt;

&lt;p&gt;在公司，我今年成功晋级T3高级设计师，算是一个期待了挺久，最终也顺利达成的目标。从进入腾讯到现在一共三年，每半年一次升级，都没有拉下，比较顺利，这过程中也要感谢周围的同事和领导。&lt;/p&gt;

&lt;p&gt;今年我做了大小几十次演讲，两次公司级的演讲，两次部门级的和两次跨部门的分享。其实演讲也是一种需要大量练习才能习得的技能，我现在也只是做到了最基础：弄清楚目标听众是什么，吸引他们的注意，表达我的想法。最近看了很多罗胖的罗辑思维，整体的表达非常好，我自愧太不如，以后要在这一块多加练习。&lt;/p&gt;

&lt;p&gt;今年我组织翻译和校对的书《众妙之门3》顺利出版，其实是去年一直在做的努力，在今年4月份终于有了圆满的结果。这个要感谢人民邮电出版社的编辑赵轩，感谢ISUX的小伙伴们~&lt;/p&gt;

&lt;p&gt;技术学习方面，粗而广地学了一些东西，nodejs、mongodb、objective-c、Angularjs、响应式流程等。我学技术的原则是熟练度可以不高，但原理和模式一定要理解。&lt;/p&gt;

&lt;p&gt;读书方面，今年读了很多老书，开始书架重读计划，我觉得读书不能贪多和贪数字。&lt;/p&gt;

&lt;p&gt;最后的最后，跟melody恋爱三年了，以前坐在我的自行车横杆，现在坐在我的副驾，我想，以后无论发生什么，我们也能一路走下去吧。&lt;/p&gt;
</description>
				<pubDate>Mon, 23 Dec 2013 09:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/2013-year/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/2013-year/</guid>
			</item>
		
			<item>
				<title>激励与响应</title>
				<description>&lt;p&gt;2013年12月15日，天津市政府召开新闻发布会，宣布实行小客车总量调控管理以及实施机动车限行交通管理措施，也就是“限购＋限行”。&lt;a href=&quot;http://news.xinhuanet.com/fortune/2013-12/16/c_125863248.htm&quot;&gt;原文&lt;/a&gt; 。管理措施12月16日凌晨生效。&lt;/p&gt;

&lt;p&gt;当晚天津市民排队抢购小汽车，4S店和二手车交易市场通宵营业，新车和二手车都需要加价购买。&lt;/p&gt;

&lt;p&gt;因为鼠患严重，河内的法国殖民政府曾经颁布过一条法令：人们每交出一只死老鼠，政府就给他发钱。这导致一些民众饲养老鼠，以此赚钱。&lt;/p&gt;

&lt;p&gt;因为法国皇帝希望用一种简单方便的办法征收房产税，提出了“窗户税”：即根据每一户的窗户数量来征收税收，这导致（经过近百年的变迁）法国一些房子不再建造窗户，终年潮湿阴暗。&lt;/p&gt;

&lt;p&gt;公司对部门的考核是“收入”，那么部门的BD对完谈合作的时候就会说我用平台和渠道免费营销你的产品，但是只有当你的销量达到500万的时候才免费。所以先收100万的现金，到时候再返还给商户。&lt;/p&gt;

&lt;p&gt;这样做，BD也也等于让步得到了谈判的资本，自己的KPI也达到了，但实际上股东利益并没有得到保证。&lt;/p&gt;

&lt;p&gt;简单的说，第一，一旦有激励加入游戏或者改变了激励，人们就会迅速而激烈地改变自己的行为；第二，人们是对激励做出反应，而不是对激励背后的目的做出反应。&lt;/p&gt;

&lt;p&gt;如果你对某个人或某个组织的行为感到吃惊，那后面90%隐藏着什么激励机制。&lt;/p&gt;
</description>
				<pubDate>Mon, 16 Dec 2013 09:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/motivate-and-response/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/motivate-and-response/</guid>
			</item>
		
			<item>
				<title>Bigpipe用Nodejs的实现</title>
				<description>&lt;p&gt;&lt;section&gt;&lt;/p&gt;

&lt;h1&gt;Bigpipe用Nodejs的实现&lt;/h1&gt;


&lt;p&gt;&lt;a href=&quot;http://yuguo.us/weblog/bigpipe-in-nodejs&quot;&gt;http://yuguo.us/weblog/bigpipe-in-nodejs/&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;
&lt;small&gt;Created by &lt;a href=&quot;http://yuguo.us&quot;&gt;Yuguo&lt;/a&gt;&lt;/small&gt;
&lt;/p&gt;


&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Source &amp;amp; Thanks&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/undoZen&quot;&gt;https://github.com/undoZen&lt;/a&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;什么是Bigpipe&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;是一种不局限于语言的前后端整合技术方案&lt;/li&gt;
&lt;li&gt;由Facebook首创&lt;/li&gt;
&lt;li&gt;适合比较大型的，需要大量服务器运算的站点&lt;/li&gt;
&lt;li&gt;有效减少HTTP请求&lt;/li&gt;
&lt;li&gt;兼容多浏览器
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe解决的问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;下载阻塞&lt;/li&gt;
&lt;li&gt;服务器与浏览器算力浪费
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;现有的阻塞模型&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/files/2013/12/traditional-network.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;页面解析步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;浏览器发送HTTP请求&lt;/li&gt;
&lt;li&gt;服务器接收到HTTP请求，解析请求，从存储层拉取数据，拼接HTML，发回一个HTTP响应&lt;/li&gt;
&lt;li&gt;这个请求通过网络传输到浏览器&lt;/li&gt;
&lt;li&gt;浏览器解析接收到的数据，构造DOM树，下载CSS和JavaScript&lt;/li&gt;
&lt;li&gt;浏览器下载了CSS之后，开始解析CSS，渲染页面&lt;/li&gt;
&lt;li&gt;下载JavaScript之后，开始解析JavaScript，执行JavaScript
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;传统流程&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;整个完整的页面&lt;/strong&gt;渲染依次经过以下步骤。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe解析步骤&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;每一个Pagelet&lt;/strong&gt;都经过以下每一个步骤才会出现在浏览器中，但是多个Pagelet可以同步进行处理。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe的速度提升&lt;/h2&gt;

&lt;p&gt;Facebook的Pagelet&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/2013/12/facebook.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe的速度提升&lt;/h2&gt;

&lt;p&gt;Facebook的Pagelet&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/2013/12/facebook-page-parts.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe的速度提升&lt;/h2&gt;

&lt;p&gt;页面分片越多，性能提升越明显&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/2013/12/facebook-bigpipe.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe不适合&lt;/h2&gt;

&lt;p&gt;简单页面，适合服务器直出全部HTML
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;YSlow优化建议&lt;/h2&gt;

&lt;p&gt;提早flush
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;flush()&lt;/h2&gt;

&lt;p&gt;PHP中的&lt;code&gt;flush()&lt;/code&gt;函数可以建立一个HTTP持久链接，达到分块传输的效果，YSlow建议在输出&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;之后马上&lt;code&gt;flush()&lt;/code&gt;，以便浏览器下载资源。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h1&gt;Nodejs实现Bigpipe的DEMO&lt;/h1&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Nodejs是什么&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个JavaScript运行环境&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;h2&gt;Nodejs不是什么&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不是一个库
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Bigpipe in Nodejs&lt;/h2&gt;

&lt;p&gt;是一种技术方案（Bigpipe）在一种环境（Nodejs）中的实现。&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;p&gt;Bigpipe的服务器端可以用各种语言来实现&lt;/p&gt;

&lt;h2&gt;为什么使用Nodejs？&lt;/h2&gt;

&lt;p&gt;&lt;small&gt;注：Bigpipe技术的服务器端需要HTTP1.1支持，浏览器端需要JavaScript支持。&lt;/small&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Why Nodejs?&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;异步特性适合Web，适合用少量服务器服务海量用户&lt;/li&gt;
&lt;li&gt;同一种语言模板同时运行在服务器和浏览器中&lt;/li&gt;
&lt;li&gt;开源社区支持
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;关键技术点&lt;/h2&gt;

&lt;p&gt;HTTP 1.1引入分块传输编码&lt;/p&gt;

&lt;p&gt;&lt;small&gt;注：HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。&lt;/small&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;HTTP分块传输编码格式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Transfer-Encoding: chunked
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Nodejs自动开启 chunked encoding&lt;/h2&gt;

&lt;p&gt;除非通过sendHeader()设置Content-Length头。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;Nodejs Express&lt;/h2&gt;

&lt;p&gt;使用Express简单架设一个web服务器（简化原生Nodejs http api），并使用jade来渲染页面模板（让代码简单）。
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;res.render&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;res.render(&#39;view&#39;, option);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有两个参数时，&lt;code&gt;res.render()&lt;/code&gt;自动调用&lt;code&gt;res.send()&lt;/code&gt;，res.send包括&lt;code&gt;res.end()&lt;/code&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;res.render设置第三个参数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;res.render(&#39;view&#39;, option, function(err, html){
    res.write(html);
    res.end();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置了第三个参数时，不会自动&lt;code&gt;res.end()&lt;/code&gt;，Good！
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;发送多个pagelet&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;res.render(view, options, function (err, str) {
    if (err) return res.req.next(err)
    res.setHeader(&#39;content-type&#39;, &#39;text/html; charset=utf-8&#39;)
    res.write(str)
    if (!res.pipeCount) res.end()
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要发送n个pagelet，就可以在每渲染一个pagelet之后计数-1，当全部渲染完成之后才调用&lt;code&gt;res.end()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;layout.jade&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;doctype html

head
  title Hello, World!
  link(href=&quot;/static/style.css&quot;, rel=&quot;stylesheet&quot;)
  script(src=&quot;/static/jquery.js&quot;)
  script(src=&quot;/static/jade.js&quot;)

section#s1!=s1
section#s2!=s2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;第一部分数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Hello, World!&amp;lt;/title&amp;gt;
&amp;lt;link href=&quot;/static/style.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
&amp;lt;script src=&quot;/static/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;/static/jade.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;section id=&quot;s1&quot;&amp;gt;
&amp;lt;span id=&quot;pipe_08554240758530796_1386255294914&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;section id=&quot;s2&quot;&amp;gt;
&amp;lt;span id=&quot;pipe_020325828110799193_1386255294914&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/section&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;第二部分数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
$(&quot;#pipe_08554240758530796_1386255294914&quot;)
.replaceWith(&quot;&amp;lt;h1&amp;gt;Partial 1&amp;lt;/h1&amp;gt;&amp;lt;div class=\&quot;content\&quot;&amp;gt;&quot;+
+&quot;Hello, I&#39;m the first section.&amp;lt;/div&amp;gt;&quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;第三部分数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
$(&quot;#pipe_020325828110799193_1386255294914&quot;)
.replaceWith(&quot;&amp;lt;h1&amp;gt;Partial 2&amp;lt;/h1&amp;gt;&amp;lt;div class=\&quot;content\&quot;&amp;gt;&quot;
+&quot;Hello, I&#39;m the second section. Takes 5 seconds to render.&amp;lt;/div&amp;gt;&quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;第四部分数据&lt;/h2&gt;

&lt;p&gt;空数据（END）
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;更复杂的实现&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
big_pipe.onPageletArrive(
{id:&quot;pagelet_composer&quot;,
content:&quot;&amp;lt;HTML&amp;gt;&quot;,
css:&quot;[..]&quot;,
js:&quot;[..]&quot;,
…}
);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h1&gt;Thank You!&lt;/h1&gt;

&lt;p&gt;&lt;small&gt;Created by &lt;a href=&quot;http://yuguo.us&quot;&gt;Yuguo&lt;/a&gt;&lt;/small&gt;
&lt;/section&gt;&lt;/p&gt;

&lt;p&gt;&lt;section data-markdown&gt;&lt;/p&gt;

&lt;h2&gt;课后问答&lt;/h2&gt;

&lt;p&gt;Bigpipe对SEO的影响是什么？如何解决？
&lt;/section&gt;&lt;/p&gt;
</description>
				<pubDate>Fri, 06 Dec 2013 09:35:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/bigpipe-in-nodejs/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/bigpipe-in-nodejs/</guid>
			</item>
		
			<item>
				<title>前端工业化3：VCS</title>
				<description>&lt;p&gt;任何慎重地对待编程的程序员和团队都会使用VCS（主要是Git或者SVN），主要有这样几个作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于程序员个人，记录代码避免丢失，方便查看修改并回溯，分支同一个代码仓库中的不同需求，记录小型里程碑&lt;/li&gt;
&lt;li&gt;对于团队协作来说，VCS的自动合并能省去我们95%的合并代码工作量&lt;/li&gt;
&lt;li&gt;对于代码审查者来说，方便监视主干代码的修改，并接受或者拒绝提交的代码&lt;/li&gt;
&lt;li&gt;通过使用一些行为钩子，可以在VCS行为之前或者之后自动触发其它事件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我在加入ISUX团队之前是一个菜鸟学生，从来没有使用过VCS，对于当时的我来说，SVN就只有一个作用：&lt;strong&gt;合并代码到主干&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;所以当时的我既累又容易出错，因为我使用SVN的方法完全错误：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在trunk上直接开发&lt;/li&gt;
&lt;li&gt;完成一个完整的需求才commit一次&lt;/li&gt;
&lt;li&gt;只commit这个需求需要的文件和代码，人工检查&lt;/li&gt;
&lt;li&gt;代码库中残留越来越多没有提交的脏代码&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我没有利用到SVN的其它功能：频繁记录代码里程碑，多个分支切换，让这些外部信息从大脑里释放，保持代码库的干净。但是随着我需要接入的项目越来越多，越来越需要快速在多个项目切换，并且也开始使用其它VCS（Git），我开始对VCS有了更好的理解。&lt;strong&gt;VCS并不只是帮助代码合并的团队工具，也是个人管理代码的很好方式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我现在非常喜欢使用Git管理版本，因为它跟SVN有一个完全不同的地方是它是分布式的，完整的代码库存在在每一台部署了代码库的机器上，我在本地切换分支，新建分支非常快，秒级生效，而且无需网络就可以commit代码。最后，世界上最好的开源代码社区是使用Git搭建（Github），你还有什么理由不使用Git呢？&lt;/p&gt;

&lt;p&gt;关于各种VCS的用法和实践，其实我不用在本文一一说明，因为资料已经太多。推荐阅读：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;&amp;lt;http://www.ruanyifeng.com/blog/2012/07/git.html&gt;&quot;&gt;Git分支管理策略&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&amp;lt;http://www.tigris.org/scdocs/SVNTips.html.zh-cn&gt;&quot;&gt;SVN最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&amp;lt;http://ihower.tw/blog/archives/5140&gt;&quot;&gt;Git flow开发流程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Tue, 26 Nov 2013 01:00:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/front-end-industrialize-vcs/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/front-end-industrialize-vcs/</guid>
			</item>
		
			<item>
				<title>前端工业化2：缓存</title>
				<description>&lt;blockquote&gt;&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and naming things.&lt;/p&gt;

&lt;p&gt;-- Phil Karlton&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;缓存基础&lt;/h2&gt;

&lt;p&gt;在开始讲缓存技术之前，需要先了解设置缓存有两个作用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对客户来说，减少请求，可以更快加载页面。如果客户是在手机上用3G访问页面，那也能节省他的流量。&lt;/li&gt;
&lt;li&gt;对网站来说，减少带宽压力，如果有1亿的访问量，如果能在CSS上节省10k，那也是非常庞大的流量节省。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;从技术上讲，有两种技术被统称为“缓存”。&lt;/p&gt;

&lt;p&gt;一个被称为&lt;strong&gt;高速缓存&lt;/strong&gt;，浏览器直接从缓存中读取文件而不发出任何请求。另一个是&lt;code&gt;HTTP 304&lt;/code&gt;（Cache Control），浏览器会询问服务器文件是否更改，服务器回答没有修改（304），或者修改了（200）。&lt;/p&gt;

&lt;p&gt;想要详细的了解，可以看看我去年的一篇旧文&lt;a href=&quot;http://yuguo.us/weblog/send-the-correct-headers-to-leverage-browser-caching/&quot;&gt;如何正确设置缓存&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;结论是：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;200(缓存)是最快的，因为没有请求发生。304则产生了HTTP请求：浏览器发送一个带有&lt;code&gt;If-Modified-Since&lt;/code&gt;的请求，服务器根据情况返回304来告诉浏览器使用本地文件。&lt;/p&gt;

&lt;p&gt;所以304比200（缓存）慢一点，静态文件都应该使用Expires头来减少请求，提高访问速度。（根据HTTPWATCH的说法：“Don&#39;t cache HTML, Cache everything else forever”）&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;Ajax与缓存&lt;/h3&gt;

&lt;p&gt;Ajax调用就像任何其他的HTTP请求一样可以用来构建一个网页。然而，由于其动态的性质人们常常忽略了可以缓存它们而从中受益。&lt;/p&gt;

&lt;p&gt;高性能网站建设的第14条规则:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;缓存Ajax&lt;/p&gt;

&lt;p&gt;确保您的Ajax请求遵循这条规则，特别是包含一个Expires头。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;现代浏览器的HTTP系统和缓存系统要比Ajax的&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象更靠近底层. 在这个层面上，浏览器并不知道或关心Ajax请求。它只是服从正常的基于从服务器返回的HTTP响应头缓存规则。&lt;/p&gt;

&lt;p&gt;如果你已经知道HTTP缓存，您可以将这种知识应用到Ajax的缓存。&lt;/p&gt;

&lt;p&gt;当然，如果您使用Ajax的POST方法，这并不适用，因为POST请求不会被缓存。如果您的Ajax请求有安全性要求，你应该总是使用POST方法，例如：银行帐户的资金转账。&lt;/p&gt;

&lt;h2&gt;缓存与更新缓存&lt;/h2&gt;

&lt;p&gt;在几年前，我们团队控制缓存的唯一办法就是把资源丢到&lt;code&gt;/ac/&lt;/code&gt;路径上去发布，CDN对这个文件夹的处理方式是输出的HTTP header设置更长的缓存时间。而要更新缓存就是手动修改对文件引用路径的query string。&lt;/p&gt;

&lt;p&gt;历史在进步，后来我们的CDN权限支持url query string的方法来吐出对应的缓存header。从这个时候开始，我们的资源请求都变成了这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://ctc.qzonestyle.gtimg.cn/qzone_v6/icenter.css?max_age=19830212&amp;amp;d=131016151112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过修改query string，就可以控制返回header的cache-control。后面的d则是无意义的字符串，当有新版本的时候我们需要半自动去修改它，对于浏览器来说只要修改了query string，它就认为是请求了新文件，从而放弃本地缓存而重新请求。&lt;/p&gt;

&lt;p&gt;这种通过修改query string更新缓存的方法有几个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这种方法是替换的方法来发布，那么在“html生效”和“css生效”之间如果出现任何时间差，哪怕是10s，就会出现错误的情况。尤其是雪碧图如果是自动计算生成的，错位就很严重了，几乎满屏的雪碧图都会错位。腾讯有几十台CDN，无法保证生效时间的精确性。&lt;/li&gt;
&lt;li&gt;可能遭到缓存攻击，具体可以看看&lt;a href=&quot;http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1&quot;&gt;前端工程与性能优化（上）：静态资源版本更新与缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可能被网络提供商保存一份旧文件的副本，这样即使我们更新了&amp;amp;d=xxxx这个时间戳，网络提供商也仍然给你老的文件。也就是说浏览器认为这是新文件，向网络重新请求，而网络提供商可能认为这还是老文件，所以给你旧文件。&lt;/li&gt;
&lt;li&gt;发布流程麻烦，前端工程师需要同时关注样式的生效，和时间戳的生效。&lt;/li&gt;
&lt;li&gt;缺乏对组件的动态管理和统计，因为我们相当于在本地生成了一个完整的public静态资源文件夹，然后发布出去，从那以后就跟前端没有关系了。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;修改文件名&lt;/h3&gt;

&lt;p&gt;现在我们前端同学经过跟运维同事的讨论，总结出一套更好的更新缓存的办法，修改资源的名称。所以如果现在如果你可以访问QQ空间公测版（V8）的话，抓包会发现这样的CSS请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://ctc.qzonestyle.gtimg.cn/aoi/icenter-wei131025143515.css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新的文件名有很多好处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这种方法采用增量的方法来发布，不存在“html生效”和“css生效”之间的延迟，因为css可以提前发布生效，html再调用新的文件&lt;/li&gt;
&lt;li&gt;遇到问题回滚简单，不用回滚所有的静态资源，只需要回滚html&lt;/li&gt;
&lt;li&gt;完全杜绝了网络提供商提供旧文件副本的问题&lt;/li&gt;
&lt;li&gt;使用不规律的文件名，不可能遭到缓存攻击&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;我只是简单提到了运行原则，但是实际操作中有很多细节要处理，包括前端同学要注意的和运维同学在CDN上的工作量。新的缓存策略现在还在试行之中，所以也没有全面部署，只有在未来有了更自动化的方案的时候才会全面部署。&lt;/p&gt;
</description>
				<pubDate>Wed, 30 Oct 2013 14:00:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/frontend-industrialize-2/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/frontend-industrialize-2/</guid>
			</item>
		
			<item>
				<title>前端工业化1：自动化</title>
				<description>&lt;p&gt;最近在学习百度前端工程师张云龙的F.I.S系统的时候，了解到他关于“前端工业化”的理解，我也经历过很多前端架构方法和架构工具的变迁，所以希望借写这篇文章的机会，自己也整理一下。&lt;/p&gt;

&lt;p&gt;之前有读者建议我写写关于D.R.Y的经验，其实好的架构能让你免于Repeat Yourself。但是架构的目的不仅限于在开发者侧更轻松，更有组织，而更重要的是在客户侧更简洁纯粹。&lt;/p&gt;

&lt;p&gt;张云龙关于架构有一段话很好：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;因为优化原则中很多要求是与工程管理相违背的，比如“把css放在头部”和“把js放在尾部”这两条原则，我们不能让团队的工程师在写样式和脚本引用的时候都去修改一个相同的页面文件。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;就像是硬币的两面，&lt;strong&gt;一面朝客户，关注性能、缓存、减少重复、保持一致；一面朝前端团队，关注维护、发布流程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;小型团队也需要合理的架构，这样可以增强扩展性和安全性。当网站从小团队渐渐发展到大团队，网站渐渐拥有千万用户的时候，整个流程更加要自动化。如果说求职的时候需要的“精通CSS”是考察开发者手工技艺，那么前端工业化就是关于如何让开发者团队可以无缝工作。&lt;/p&gt;

&lt;p&gt;先介绍我们Qzone团队是怎样从刀耕火种的原始时代过度到现在的。&lt;/p&gt;

&lt;h2&gt;手工&lt;/h2&gt;

&lt;p&gt;大概是2010年之前，我们SVN的目录结构很简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌ html
├ public
├ PSD
├ 规范
└ 一些批处理脚本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;public里的东西就是对应外网发布的静态资源，包括css和图片，雪碧图全手工拼接。外网代码中甚至能看到注释。&lt;/p&gt;

&lt;p&gt;CDN输出静态资源采用统一的缓存规定，好像是一个小时。要发布新代码就直接发布覆盖旧文件，反正缓存时间不长。&lt;/p&gt;

&lt;p&gt;但是我们也有长缓存的需求，比如一个黄钻vip的图标，可能一年都不会变，这时候我们规定了一个目录叫/ac/，代表长缓存，至于有多长，这个没法定制，反正运维人员给CDN统一设定了一个很长的时间，开发者想长缓存的东西就丢进去好了。&lt;/p&gt;

&lt;p&gt;这个/ac/目录出于某种神秘的原因甚至不在SVN的管理之中，我们要修改的话直接去服务器上拿（后来那台服务器挂了，我们就从外网拿）。&lt;/p&gt;

&lt;h2&gt;cssgaga&lt;/h2&gt;

&lt;p&gt;因为我们发布文件的第一步需要把文件放在一台服务器上，然后通过发布系统分发到CDN。放文件这个过程不是很优雅，也不太可靠。需要我们打开两个资源管理器（远程服务器还要输入用户名和密码），然后拷贝过去。&lt;/p&gt;

&lt;p&gt;第二步，分发系统（ARS）需要知道文件在哪台服务器上的哪个路径（linux路径），所以我们提交发布单的时候还要提供linux路径列表（称为提单列表），这就很麻烦。&lt;/p&gt;

&lt;p&gt;于是我们的团队成员&lt;a href=&quot;http://www.99css.com/&quot;&gt;yt&lt;/a&gt; 就研发了一个工具叫做&lt;a href=&quot;http://www.99css.com/archives/tag/cssgaga&quot;&gt;cssgaga&lt;/a&gt;。在windows上运行，简单配置之后，只要把需要发布的文件拖拽到工具里，就可以自动登录远程服务器并且把文件放在对应的地方，非常方便。&lt;/p&gt;

&lt;p&gt;再后来，yt慢慢在cssgaga中加入了更多的功能，比如css文件中的@import语法，可以自动合并成一个css文件，这样减少了http请求和渲染阻塞。&lt;/p&gt;

&lt;p&gt;还有data-uri，可以把引入的图片变成data-url，进一步请求，不过这个比较极端，很少用到。比如图片关联性检查，会遍历CSS中对img的引用，并自动生成提单列表。&lt;/p&gt;

&lt;p&gt;真正让cssgaga成为团队必不可少人人都用的是在2010年12月，cssgaga加入了自动雪碧图的功能，那篇介绍雪碧图功能的文章获得了80个评论。因为市面上的雪碧图工具都不太好用，拼雪碧图还处于半手工的状态，而cssgaga是完全自动化的。&lt;/p&gt;

&lt;p&gt;其实cssgaga这几年一直都在更新，加入了大量团队需要的功能，但是最核心的几条原则从来没有改变过：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;本地的CSS源码也是完全合法的语法，没有自定义的语法规则，可以直接打开静态页面，最终cssgaga生成的代码也是最符合雅虎14条的压缩代码。&lt;/li&gt;
&lt;li&gt;assets之间的关系通过合法的语法关联起来，而不是像F.I.S或者Grunt那样有一个配置关联表。举例来说，多个css组件被@import到同一个A.css中，然后拖A.css的时候就会自动搜寻相对路径中的那些css进来。拖某个css到cssgaga中（并勾选检查关联性），就会自动搜寻当前目录下所有@import了这个css的css文件，并全部发布。&lt;/li&gt;
&lt;li&gt;黑盒+不开源&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我很欣赏yt有自己的坚持，有清晰的理念支持的工具，但是我们也应该了解其他可能的选择。&lt;/p&gt;

&lt;h2&gt;Shell编程&lt;/h2&gt;

&lt;p&gt;之前写过一篇文章&lt;a href=&quot;http://yuguo.us/weblog/make-bootstrap/&quot;&gt;Bootstrap的编译机制&lt;/a&gt;，当时Bootstrap的CSS文件是使用Make来编译的，如果你没有看过这篇文章，强烈推荐你先阅读这篇文章，再回来也许能更好的理解Make。&lt;/p&gt;

&lt;p&gt;GNU make是一个方便的工具，目的是把大量的shell 命令组合起来完成一个任务。这些命令之所以能组合起来，跟Linux哲学是息息相关的：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;程序要能协作。程序要能处理文本流，因为这是最通用的接口。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;程序协作是通过“依赖”来实现，而make能很好地解决任务之间的依赖问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gh-pages: bootstrap docs
    rm -f docs/assets/bootstrap.zip
    zip -r docs/assets/bootstrap.zip bootstrap
    rm -r bootstrap
    rm -f ../bootstrap-gh-pages/assets/bootstrap.zip
    node docs/build production
    cp -r docs/* ../bootstrap-gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;gh-pages是工作目标；&lt;/li&gt;
&lt;li&gt;bootstrap docs是必要条件；&lt;/li&gt;
&lt;li&gt;以后的6行是命令&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Makefile的语法是linux shell语法，所以对于前端开发来说需要一定的学习成本。这里有一篇不错的文章，可以看一下&lt;a href=&quot;http://www.linuxforu.com/2012/06/gnu-make-in-detail-for-beginners/&quot;&gt;GNU Make in Detail for Beginners&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;Grunt&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://Gruntjs.org&quot;&gt;Grunt&lt;/a&gt;的自我介绍是：“The JavaScript Task Runner”。&lt;/p&gt;

&lt;p&gt;Grunt 是一个开源的基于任务 (Task) 的前端构建框架。它除了有 Jake 的优点（跨平台、开发简单）以外，还有一套设计良好的 task 框架用来组织各种构建任务。Grunt 内置了几个非常常见的构建任务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; concat - 组合各种文件&lt;/li&gt;
&lt;li&gt; lint - 用 JSHint 检查代码&lt;/li&gt;
&lt;li&gt; min - 用 UglifyJS 压缩代码&lt;/li&gt;
&lt;li&gt; qunit - 跑 QUnit 单元测试&lt;/li&gt;
&lt;li&gt; watch - 当源代码文件发生变化时自动执行任务&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;除此之外还可以通过 npm 来方便的获取几百个现成的 task，比如用 closure 而不是 UglifyJS 来压缩 js，或者用 less 来生成 css，又或者用 jslint 而不是 jshint 来检查语法等，这些任务都可以在 npm 上找到。如果这些任务无法满足你的需求，Grunt 还允许你方便的添加自定任务，就像写 nodejs 代码一样简单。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于前端开发者来说，Grunt语法可比Shell友好多了，而且Gruntfile.js是合法的javascript文件，在里面可以运行任何合法的javascript代码，非常灵活。&lt;/strong&gt;关于从Shell过度到Grunt这个过程，有兴趣的可以参考这篇文章&lt;a href=&quot;http://lostjs.com/2012/12/08/Grunt-the-best/&quot;&gt;Grunt -- 最好的前端构建框架&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;话分两边，工具侧我们一直没有停止进步，朝着更自动化的方向迅猛发展。那么真正面向用户的缓存和请求侧又有哪些进展呢，下一篇日志会讲讲缓存和更新缓存。&lt;/p&gt;
</description>
				<pubDate>Fri, 25 Oct 2013 14:00:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/frontend-industrialize/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/frontend-industrialize/</guid>
			</item>
		
			<item>
				<title>我是怎么阅读的</title>
				<description>&lt;p&gt;我平时的阅读包括读书和网上的文章，我记忆力不是太好，不可能达到过目不忘的程度，所以读了好书之后往往还会再多读几次。&lt;/p&gt;

&lt;p&gt;关于笔记，下面这些办法都是为了方便第二次看的时候更快进入角色。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;关于电子书来源，我默认都是从多看上购买，如果amazon.cn上有多看上没有的书源，就切换系统去购买。一方面是因为购买很方便，时间就是金钱，另一方面电子书已经很便宜了，在能力可以的时候尽量还是去购买正版吧。&lt;/li&gt;
&lt;li&gt;在网上看到好的文章，或者查阅到有用的文章的时候，不使用read later类的服务，因为read later = read never。我会保存到evernote里去，然后在evernote里做一遍“沥水”的工作：去掉无关紧要的内容，去掉废话，把重要的部分高亮。&lt;/li&gt;
&lt;li&gt;看的过程中比较有感悟的地方做一下书摘，也可以导出到evernote。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这样的好处是以后可以统一在evernote里搜索相关内容，然后可以快速看高亮的部分。&lt;/p&gt;

&lt;p&gt;此外，我认为最好的读书过程是每读完一章就用自己的话总结一下这一章说了些啥。读的过程中有书摘，方便第二次直接看书摘。﻿&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://yuguo.us/weblog/kindle-paperwhite/&quot;&gt;kindle paperwhite是迄今最好的阅读器&lt;/a&gt;（也是最便宜的！），每一个喜欢读书的人都应该买一台，如果准备买的话，我左边有个广告链接，可以去我女朋友的淘宝店海淘一个。&lt;/p&gt;

&lt;p&gt;关于阅读时间，早上在车上居多，晚上也会看一段时间，现在根据统计，每天的平均阅读时间已经降到40分钟/天了，之前是2小时/天。从5月份&lt;a href=&quot;http://yuguo.us/weblog/repick-kindle/&quot;&gt;重拾kindle&lt;/a&gt;之后，已经购买了42本书，大部分都看完了。&lt;/p&gt;

&lt;p&gt;其实，最终我想说的是，读书的过程是很美，拿着kindle paperwhite在地铁上掏出来也恍惚有一种文艺青年的感觉。但是最终我们看重的应该是真正进入大脑的“无形”的知识，以及引起的思考，而我们付出的代价就是金钱和时间，金钱是廉价的代价，而时间是更大的代价。硬件只是书籍的承载，让你可以方便的阅读，如果把阅读搞得更麻烦了，就不要去做这件事。&lt;/p&gt;

&lt;p&gt;所以，阅读的时候，时刻记住自己为什么阅读，就能放弃很多无谓的折腾，进入到一个纯粹的精神世界。&lt;/p&gt;

&lt;p&gt;最后以一碗鸡汤作为结尾：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  有个年轻人崇拜杨绛，高中毕业的时候给杨绛写了一封长信，表达自己的仰慕之情兼倾诉人生困惑，杨绛给他回信了。淡黄色的竖排红格信纸，毛笔字。除了寒暄和一些鼓励晚辈的句子之外，杨绛的信里其实只写了一句话，诚恳而不客气：“你的问题主要在于读书不多而想得太多。”&lt;/p&gt;&lt;/blockquote&gt;
</description>
				<pubDate>Mon, 14 Oct 2013 14:00:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/my-reading/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/my-reading/</guid>
			</item>
		
			<item>
				<title>腾讯三年</title>
				<description>&lt;p&gt;博客停了一个多月，期间也想过写一些东西，但都是在evernote里起草了部分之后又觉得自己文笔和思路都不够好，就删掉了。这两个月发生的事情非常多，我就随意记录一下，谈谈我的想法吧。&lt;/p&gt;

&lt;h2&gt;腾讯三年&lt;/h2&gt;

&lt;p&gt;进入腾讯三年，从助理设计师一步步晋级到高级设计师，期间的感悟和辛苦都只有自己能获益，就像王小波的《沉默的大多数》中说的：人们都是从沉默中学习，而不是从话语中学习。如果我总结出任何话语，比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要积极响应上下游的需求&lt;/li&gt;
&lt;li&gt;要主动关注业务&lt;/li&gt;
&lt;li&gt;你必须非常努力，才能看上去毫不费力&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这些话语在说出来的瞬间，它就脱离了土壤，成为空中楼阁，被人冠以“政治正确”、“装逼”的帽子。&lt;/p&gt;

&lt;p&gt;我喜欢把人分为两类，一种是看见任何社会现象都会嘲弄一把（或者叫黑一把），另一种是看见任何事情都能想想自己从中学到什么的。前者是话语的世界，后者是沉默的世界。&lt;/p&gt;

&lt;h2&gt;买房&lt;/h2&gt;

&lt;p&gt;之前我是坚定地不买房。现在我买了，五个原因：&lt;/p&gt;

&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;第四次搬家的一个房子还挺喜欢的，但是准备续租的时候，房东不租了，加钱都不租。&lt;/li&gt;
&lt;li&gt;入职三年，表现良好，腾讯提供三十万无息贷款。&lt;/li&gt;
&lt;li&gt;自己判断 &lt;strong&gt;深圳&lt;/strong&gt; &lt;strong&gt;前海&lt;/strong&gt;房价还有上涨空间。&lt;/li&gt;
&lt;li&gt;深圳是不错的城市。&lt;/li&gt;
&lt;li&gt;小平在这件事上表现出了鲜有的极高的行动力。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;所以一个月内就把房子看好买进了，现在已经入住。&lt;/p&gt;

&lt;h2&gt;知乎&lt;/h2&gt;

&lt;p&gt;之前每天的班车上我都是看kindle，最近两个月开始偶尔刷知乎。认为这也是这几个月非常大的一件事，因为我从中学到的东西太多了。&lt;/p&gt;

&lt;p&gt;关注了一些现在的我只能仰视的人，感慨他们的文笔和思路都是如此清晰，这也算是我博客搁置的一个小小因素，因为觉得了自己的渺小。&lt;/p&gt;

&lt;p&gt;但是其实知乎上还有些人其实都是看见问题就站队伍，扣帽子。比如这个问题：&lt;a href=&quot;http://www.zhihu.com/question/21292446&quot;&gt;怎样劝说男朋友不要看新闻联播？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;站队伍的同学看见这个问题就嗨了，首先就站在“新闻联播”的对立面（站队伍），准备来“黑”一把（浪费时间），称“新闻联播”为“官媒”、“传声筒”（扣帽子）。&lt;/p&gt;

&lt;p&gt;我学到的是不管什么问题出现了，不要因为对问题中的某个人物或者组织不满就站队伍，扣帽子，这跟文革红卫兵是一个性质的。不了解的话题不赞同，只感谢。&lt;/p&gt;

&lt;h2&gt;读书&lt;/h2&gt;

&lt;p&gt;最近的书推荐4本，非虚构类的《第五项修炼》、《清醒思考的艺术》和《精益创业》，虚构类的《黑笑小说》。四本书在多看书城都有售。&lt;/p&gt;

&lt;p&gt;《清醒思考的艺术》其实已经在六月荐书单里推荐过了，但是这两个月又重新看了一遍。这本书是很轻松的，每个短小章节都介绍了一种思维误区。&lt;/p&gt;

&lt;p&gt;先提另一本书，大学看的一本书《写给大家看的设计书》里有一个原理叫做“约书亚树原理”，是说“只要你能说出什么东西的名字，你就很容易注意到它”。&lt;/p&gt;

&lt;p&gt;我对《清醒思考的艺术》中的一章“干掉你的宠儿”印象比较深刻，之后我就随时随地注意到了这种现象。&lt;/p&gt;

&lt;p&gt;有一些同事是买了房的，他坚信（其实是希望）房价继续上涨，达到他入手价格的两倍才够。这时候他会看到很多支持他观点的“事实”，比如中央调控又加紧了，预示着需求被抑制；比如跟去年比环比价格提高多少。&lt;/p&gt;

&lt;p&gt;而另一些同事没买房而又希望房价下跌的，他会看到很多支持他观点的“新闻”，比如跟上周比环比交易数下跌，交易价格下跌等……&lt;/p&gt;

&lt;p&gt;这个世界的资讯这么多，反而让人们更加偏颇和专横，而不是兼容包并。微博和搜索让我们越是希望证明什么观点，我们越是能找到支持这种观点的证据。&lt;/p&gt;

&lt;p&gt;事情过去之后，这些观点要是能回头看，自己都会觉得好笑，所以我之前在QQ空间还说，回头看3年前的自己，就是一个纯傻逼，6年前的，更是傻到冒泡。希望三年后看自己也是这样的。&lt;/p&gt;

&lt;p&gt;要走出这个思维误区很简单，总是证明自己是错的，而不是证明自己是对的。&lt;/p&gt;

&lt;h2&gt;入手macbook retina&lt;/h2&gt;

&lt;p&gt;这个绝对物超所值，现在已经完全习惯ssd硬盘的启动速度，还有retina的画面渲染，回不去了。apple产品还是比较保值，最好是隔一代产品就换一次，把老的出掉。&lt;/p&gt;

&lt;h2&gt;翻译新书&lt;/h2&gt;

&lt;p&gt;在组织翻译一本书《Responsive design workflow》（《响应式设计工作流程》），是New Rider出版社的，由人民邮电出版社引进，现在进度50%了。&lt;/p&gt;

&lt;p&gt;一般的响应式设计的文章都会在某一个点上着墨，比如从技术上怎么实现多个设备断点变化，比如设计师如何设计多个尺寸的页面。而这本书把所有的独立过程都串起来了，我在翻译的过程中也是觉得很有价值的一本书。就像《第五项修炼》中的“系统思考”所描述的，你必须要有一个全局的实业，摒除传统的“流水线”思维。&lt;/p&gt;

&lt;p&gt;变化正在到来，敬请期待。&lt;/p&gt;
</description>
				<pubDate>Tue, 01 Oct 2013 10:40:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/tencent-3-years/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/tencent-3-years/</guid>
			</item>
		
			<item>
				<title>介绍Reveal.js</title>
				<description>&lt;p&gt;jQuery reveal是最近在用的一个jQuery插件，作用是控制弹出层的显示和消失。这个插件非常轻量，而且使用简单，如果页面中已经加载了jQuery的话，只需要额外1.35k的大小就能使用reveal.js。&lt;/p&gt;

&lt;p&gt;使用方法可以在其&lt;a href=&quot;http://zurb.com/playground/reveal-modal-plugin&quot;&gt;官方网站&lt;/a&gt;上看到介绍。&lt;/p&gt;

&lt;h2&gt;链接触发浮层&lt;/h2&gt;

&lt;p&gt;首先加载需要的样式、jQuery和reveal.js之后，我们如果需要点击一个链接弹出一个弹出层，只需要在链接中加上&lt;code&gt;data-reveal-id&lt;/code&gt;属性：&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://snipt.net/embed/a7a11463256a8e55e13ab69feadfa9d0/&quot;&gt;&lt;/script&gt;


&lt;p&gt;然后在对应弹出层的id跟链接的&lt;code&gt;data-reveal-id&lt;/code&gt;保持一致即可。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://snipt.net/embed/3bc5dfa546b4780472545eb8fea109f6/&quot;&gt;&lt;/script&gt;


&lt;p&gt;浮层一般会有一个关闭按钮，我们不用在按钮上绑定事件来关闭浮层了，只需要简单地使用class：&lt;code&gt;close-reveal-modal&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2&gt;代码触发浮层&lt;/h2&gt;

&lt;p&gt;有时候我们希望用代码来触发浮层操作，也非常简单：&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://snipt.net/embed/d497a8f659e1c610f6ce1a48e8669105/&quot;&gt;&lt;/script&gt;


&lt;p&gt;如果要使用html属性来触发这些option，也可以：&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://snipt.net/embed/34db731ca7ab2b9eabe5ac5dd381ea28/&quot;&gt;&lt;/script&gt;


&lt;p&gt;总的来说，使用reveal.js插件可以帮助我们更专注于页面逻辑，也不用在页面事件和触发上操太多心。&lt;/p&gt;
</description>
				<pubDate>Tue, 20 Aug 2013 17:40:00 +0800</pubDate>
				<link>http://yuguo.us/weblog/introduce-revealjs/</link>
				<guid isPermaLink="true">http://yuguo.us/weblog/introduce-revealjs/</guid>
			</item>
		
	</channel>
</rss>